<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReShade: reshade::api::command_list Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="main_icon_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReShade
   </div>
   <div id="projectbrief">A generic post-processing injector for games and video software.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereshade.html">reshade</a></li><li class="navelem"><a class="el" href="namespacereshade_1_1api.html">api</a></li><li class="navelem"><a class="el" href="structreshade_1_1api_1_1command__list.html">command_list</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structreshade_1_1api_1_1command__list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reshade::api::command_list Struct Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A command list, used to enqueue render commands on the CPU, before later executing them in a command queue.  
 <a href="structreshade_1_1api_1_1command__list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="reshade__api__device_8hpp_source.html">reshade_api_device.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reshade::api::command_list:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structreshade_1_1api_1_1command__list.png" usemap="#reshade::api::command_5Flist_map" alt=""/>
  <map id="reshade::api::command_5Flist_map" name="reshade::api::command_5Flist_map">
<area href="structreshade_1_1api_1_1device__object.html" title="The base class for objects that are children to a logical render device." alt="reshade::api::device_object" shape="rect" coords="0,56,166,80"/>
<area href="structreshade_1_1api_1_1api__object.html" title="The base class for objects provided by the ReShade API." alt="reshade::api::api_object" shape="rect" coords="0,0,166,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73e3d799c04a6e232b707b0c49666c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a73e3d799c04a6e232b707b0c49666c73">barrier</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>, <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a> old_state, <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a> new_state)</td></tr>
<tr class="memdesc:a73e3d799c04a6e232b707b0c49666c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a barrier for the specified <em>resource</em>  to the command stream. When both <em>old_state</em>  and <em>new_state</em>  are <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a9d625a0527071357b9b7ba12d608c8cd">resource_usage::unordered_access</a> a UAV barrier is added, otherwise a state transition is performed.  <a href="structreshade_1_1api_1_1command__list.html#a73e3d799c04a6e232b707b0c49666c73">More...</a><br /></td></tr>
<tr class="separator:a73e3d799c04a6e232b707b0c49666c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1203d24668090d42df08ea2cc99bd7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a4b1203d24668090d42df08ea2cc99bd7">barrier</a> (uint32_t count, const <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> *resources, const <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a> *old_states, const <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a> *new_states)=0</td></tr>
<tr class="memdesc:a4b1203d24668090d42df08ea2cc99bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a barrier for the specified <em>resources</em>  to the command stream.  <a href="structreshade_1_1api_1_1command__list.html#a4b1203d24668090d42df08ea2cc99bd7">More...</a><br /></td></tr>
<tr class="separator:a4b1203d24668090d42df08ea2cc99bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b9644e936983d75ca1244150c7f956"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a75b9644e936983d75ca1244150c7f956">begin_render_pass</a> (uint32_t count, const <a class="el" href="structreshade_1_1api_1_1render__pass__render__target__desc.html">render_pass_render_target_desc</a> *rts, const <a class="el" href="structreshade_1_1api_1_1render__pass__depth__stencil__desc.html">render_pass_depth_stencil_desc</a> *ds=nullptr)=0</td></tr>
<tr class="memdesc:a75b9644e936983d75ca1244150c7f956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a render pass and binds render target and depth-stencil resource views.  <a href="structreshade_1_1api_1_1command__list.html#a75b9644e936983d75ca1244150c7f956">More...</a><br /></td></tr>
<tr class="separator:a75b9644e936983d75ca1244150c7f956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7e0b86b35be07c2e03a2ea19843ace"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a4e7e0b86b35be07c2e03a2ea19843ace">end_render_pass</a> ()=0</td></tr>
<tr class="memdesc:a4e7e0b86b35be07c2e03a2ea19843ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a render pass. This must be preceeded by a call to <a class="el" href="structreshade_1_1api_1_1command__list.html#a75b9644e936983d75ca1244150c7f956" title="Begins a render pass and binds render target and depth-stencil resource views.">begin_render_pass</a>. Render passes cannot be nested.  <a href="structreshade_1_1api_1_1command__list.html#a4e7e0b86b35be07c2e03a2ea19843ace">More...</a><br /></td></tr>
<tr class="separator:a4e7e0b86b35be07c2e03a2ea19843ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b5bd17b2cb03863913efda6e01d972"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a72b5bd17b2cb03863913efda6e01d972">bind_render_targets_and_depth_stencil</a> (uint32_t count, const <a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> *rtvs, <a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> dsv={ 0 })=0</td></tr>
<tr class="memdesc:a72b5bd17b2cb03863913efda6e01d972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds individual render target and depth-stencil resource views. This must not be called between <a class="el" href="structreshade_1_1api_1_1command__list.html#a75b9644e936983d75ca1244150c7f956" title="Begins a render pass and binds render target and depth-stencil resource views.">begin_render_pass</a> and <a class="el" href="structreshade_1_1api_1_1command__list.html#a4e7e0b86b35be07c2e03a2ea19843ace" title="Ends a render pass. This must be preceeded by a call to begin_render_pass. Render passes cannot be ne...">end_render_pass</a>.  <a href="structreshade_1_1api_1_1command__list.html#a72b5bd17b2cb03863913efda6e01d972">More...</a><br /></td></tr>
<tr class="separator:a72b5bd17b2cb03863913efda6e01d972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc22fd6a89454e4ac11497d8290e1b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#abbc22fd6a89454e4ac11497d8290e1b2">bind_pipeline</a> (<a class="el" href="namespacereshade_1_1api.html#a46a70b7dcd8b1e829ff8102091b64037">pipeline_stage</a> stages, <a class="el" href="structreshade_1_1api_1_1pipeline.html">pipeline</a> <a class="el" href="structreshade_1_1api_1_1pipeline.html">pipeline</a>)=0</td></tr>
<tr class="memdesc:abbc22fd6a89454e4ac11497d8290e1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a pipeline state object.  <a href="structreshade_1_1api_1_1command__list.html#abbc22fd6a89454e4ac11497d8290e1b2">More...</a><br /></td></tr>
<tr class="separator:abbc22fd6a89454e4ac11497d8290e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804b3aa8c3f0e465e98762c27fc75798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a804b3aa8c3f0e465e98762c27fc75798">bind_pipeline_state</a> (<a class="el" href="namespacereshade_1_1api.html#a21e917814c5dd21aa28d2e6564f504d9">dynamic_state</a> state, uint32_t value)</td></tr>
<tr class="memdesc:a804b3aa8c3f0e465e98762c27fc75798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the specfified pipeline <em>state</em>  to the specified <em>value</em> . This is only valid for states that have been listed in the dynamic states provided at creation of the currently bound pipeline state object (<a class="el" href="namespacereshade_1_1api.html#ad62e21a3e52b83de83ad42ca5bebbd6aa56009880edb86cf5e2b83dc674625123" title="States that may be dynamically updated via command_list::bind_pipeline_states after binding this pipe...">pipeline_subobject_type::dynamic_pipeline_states</a>).  <a href="structreshade_1_1api_1_1command__list.html#a804b3aa8c3f0e465e98762c27fc75798">More...</a><br /></td></tr>
<tr class="separator:a804b3aa8c3f0e465e98762c27fc75798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4457eb23164ccfe161c39e2eba2a928"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#af4457eb23164ccfe161c39e2eba2a928">bind_pipeline_states</a> (uint32_t count, const <a class="el" href="namespacereshade_1_1api.html#a21e917814c5dd21aa28d2e6564f504d9">dynamic_state</a> *states, const uint32_t *values)=0</td></tr>
<tr class="memdesc:af4457eb23164ccfe161c39e2eba2a928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the specfified pipeline <em>states</em>  to the specified <em>values</em> . This is only valid for states that have been listed in the dynamic states provided at creation of the currently bound pipeline state object (<a class="el" href="namespacereshade_1_1api.html#ad62e21a3e52b83de83ad42ca5bebbd6aa56009880edb86cf5e2b83dc674625123" title="States that may be dynamically updated via command_list::bind_pipeline_states after binding this pipe...">pipeline_subobject_type::dynamic_pipeline_states</a>).  <a href="structreshade_1_1api_1_1command__list.html#af4457eb23164ccfe161c39e2eba2a928">More...</a><br /></td></tr>
<tr class="separator:af4457eb23164ccfe161c39e2eba2a928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557b2f95f05e3d05a8cf02bbd199cf5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a557b2f95f05e3d05a8cf02bbd199cf5a">bind_viewports</a> (uint32_t first, uint32_t count, const <a class="el" href="structreshade_1_1api_1_1viewport.html">viewport</a> *viewports)=0</td></tr>
<tr class="memdesc:a557b2f95f05e3d05a8cf02bbd199cf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an array of viewports to the rasterizer stage.  <a href="structreshade_1_1api_1_1command__list.html#a557b2f95f05e3d05a8cf02bbd199cf5a">More...</a><br /></td></tr>
<tr class="separator:a557b2f95f05e3d05a8cf02bbd199cf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84688340495260d6634bfe2247bb0a34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a84688340495260d6634bfe2247bb0a34">bind_scissor_rects</a> (uint32_t first, uint32_t count, const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *rects)=0</td></tr>
<tr class="memdesc:a84688340495260d6634bfe2247bb0a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an array of scissor rectangles to the rasterizer stage.  <a href="structreshade_1_1api_1_1command__list.html#a84688340495260d6634bfe2247bb0a34">More...</a><br /></td></tr>
<tr class="separator:a84688340495260d6634bfe2247bb0a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e432c00882dbaa27b99177d33d5b398"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a5e432c00882dbaa27b99177d33d5b398">push_constants</a> (<a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a> stages, <a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a> layout, uint32_t param, uint32_t first, uint32_t count, const void *values)=0</td></tr>
<tr class="memdesc:a5e432c00882dbaa27b99177d33d5b398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly updates constant values in the specified shader pipeline stages.  <a href="structreshade_1_1api_1_1command__list.html#a5e432c00882dbaa27b99177d33d5b398">More...</a><br /></td></tr>
<tr class="separator:a5e432c00882dbaa27b99177d33d5b398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d8805c699bf00279deb042dd7ffc7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a02d8805c699bf00279deb042dd7ffc7c">push_descriptors</a> (<a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a> stages, <a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a> layout, uint32_t param, const <a class="el" href="structreshade_1_1api_1_1descriptor__table__update.html">descriptor_table_update</a> &amp;update)=0</td></tr>
<tr class="memdesc:a02d8805c699bf00279deb042dd7ffc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly binds a temporary descriptor table for the specfified shader pipeline stage and updates with an array of descriptors.  <a href="structreshade_1_1api_1_1command__list.html#a02d8805c699bf00279deb042dd7ffc7c">More...</a><br /></td></tr>
<tr class="separator:a02d8805c699bf00279deb042dd7ffc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8266f2bdeeaea48e6497ed8aff127e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a8266f2bdeeaea48e6497ed8aff127e65">bind_descriptor_table</a> (<a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a> stages, <a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a> layout, uint32_t param, <a class="el" href="structreshade_1_1api_1_1descriptor__table.html">descriptor_table</a> table)</td></tr>
<tr class="memdesc:a8266f2bdeeaea48e6497ed8aff127e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a single descriptor table.  <a href="structreshade_1_1api_1_1command__list.html#a8266f2bdeeaea48e6497ed8aff127e65">More...</a><br /></td></tr>
<tr class="separator:a8266f2bdeeaea48e6497ed8aff127e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace034fd1770ba272768d779c62300174"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#ace034fd1770ba272768d779c62300174">bind_descriptor_tables</a> (<a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a> stages, <a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a> layout, uint32_t first, uint32_t count, const <a class="el" href="structreshade_1_1api_1_1descriptor__table.html">descriptor_table</a> *tables)=0</td></tr>
<tr class="memdesc:ace034fd1770ba272768d779c62300174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an array of descriptor tables.  <a href="structreshade_1_1api_1_1command__list.html#ace034fd1770ba272768d779c62300174">More...</a><br /></td></tr>
<tr class="separator:ace034fd1770ba272768d779c62300174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa24a66cda78ff105d1975a297e4314"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a8aa24a66cda78ff105d1975a297e4314">bind_index_buffer</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> buffer, uint64_t offset, uint32_t index_size)=0</td></tr>
<tr class="memdesc:a8aa24a66cda78ff105d1975a297e4314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an index buffer to the input-assembler stage.  <a href="structreshade_1_1api_1_1command__list.html#a8aa24a66cda78ff105d1975a297e4314">More...</a><br /></td></tr>
<tr class="separator:a8aa24a66cda78ff105d1975a297e4314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8618e997b035a86daa8c7c9357af90a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a8618e997b035a86daa8c7c9357af90a6">bind_vertex_buffer</a> (uint32_t index, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> buffer, uint64_t offset, uint32_t stride)</td></tr>
<tr class="memdesc:a8618e997b035a86daa8c7c9357af90a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a single vertex buffer to the input-assembler stage.  <a href="structreshade_1_1api_1_1command__list.html#a8618e997b035a86daa8c7c9357af90a6">More...</a><br /></td></tr>
<tr class="separator:a8618e997b035a86daa8c7c9357af90a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199bb68035b8cc0a70b3335d8eea545d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a199bb68035b8cc0a70b3335d8eea545d">bind_vertex_buffers</a> (uint32_t first, uint32_t count, const <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> *buffers, const uint64_t *offsets, const uint32_t *strides)=0</td></tr>
<tr class="memdesc:a199bb68035b8cc0a70b3335d8eea545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an array of vertex buffers to the input-assembler stage.  <a href="structreshade_1_1api_1_1command__list.html#a199bb68035b8cc0a70b3335d8eea545d">More...</a><br /></td></tr>
<tr class="separator:a199bb68035b8cc0a70b3335d8eea545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5be175dacc3ea67f6bed6801ff2676"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a1b5be175dacc3ea67f6bed6801ff2676">bind_stream_output_buffers</a> (uint32_t first, uint32_t count, const <a class="el" href="structreshade_1_1api_1_1resource.html">api::resource</a> *buffers, const uint64_t *offsets, const uint64_t *max_sizes, const <a class="el" href="structreshade_1_1api_1_1resource.html">api::resource</a> *counter_buffers, const uint64_t *counter_offsets)=0</td></tr>
<tr class="memdesc:a1b5be175dacc3ea67f6bed6801ff2676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an array of buffers to the stream-output stage.  <a href="structreshade_1_1api_1_1command__list.html#a1b5be175dacc3ea67f6bed6801ff2676">More...</a><br /></td></tr>
<tr class="separator:a1b5be175dacc3ea67f6bed6801ff2676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1979928ce2b057d783fab63efab846b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a1979928ce2b057d783fab63efab846b0">draw</a> (uint32_t vertex_count, uint32_t instance_count, uint32_t first_vertex, uint32_t first_instance)=0</td></tr>
<tr class="memdesc:a1979928ce2b057d783fab63efab846b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws non-indexed primitives.  <a href="structreshade_1_1api_1_1command__list.html#a1979928ce2b057d783fab63efab846b0">More...</a><br /></td></tr>
<tr class="separator:a1979928ce2b057d783fab63efab846b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc63fba83dae2e56c79eb79bc3b3820e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#acc63fba83dae2e56c79eb79bc3b3820e">draw_indexed</a> (uint32_t index_count, uint32_t instance_count, uint32_t first_index, int32_t vertex_offset, uint32_t first_instance)=0</td></tr>
<tr class="memdesc:acc63fba83dae2e56c79eb79bc3b3820e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws indexed primitives.  <a href="structreshade_1_1api_1_1command__list.html#acc63fba83dae2e56c79eb79bc3b3820e">More...</a><br /></td></tr>
<tr class="separator:acc63fba83dae2e56c79eb79bc3b3820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1b3d51f9849f69e9c3819a89751b9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a2d1b3d51f9849f69e9c3819a89751b9e">dispatch</a> (uint32_t group_count_x, uint32_t group_count_y, uint32_t group_count_z)=0</td></tr>
<tr class="memdesc:a2d1b3d51f9849f69e9c3819a89751b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a compute shader dispatch.  <a href="structreshade_1_1api_1_1command__list.html#a2d1b3d51f9849f69e9c3819a89751b9e">More...</a><br /></td></tr>
<tr class="separator:a2d1b3d51f9849f69e9c3819a89751b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bbf10afa86718f636a431910ddb0f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a85bbf10afa86718f636a431910ddb0f4">draw_or_dispatch_indirect</a> (<a class="el" href="namespacereshade_1_1api.html#a4d43e282e1516074653731962281d7a1">indirect_command</a> type, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> buffer, uint64_t offset, uint32_t draw_count, uint32_t stride)=0</td></tr>
<tr class="memdesc:a85bbf10afa86718f636a431910ddb0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes indirect draw or dispatch commands.  <a href="structreshade_1_1api_1_1command__list.html#a85bbf10afa86718f636a431910ddb0f4">More...</a><br /></td></tr>
<tr class="separator:a85bbf10afa86718f636a431910ddb0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f682681e028fbd85c57cb38078cb62a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a2f682681e028fbd85c57cb38078cb62a">copy_resource</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> source, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> dest)=0</td></tr>
<tr class="memdesc:a2f682681e028fbd85c57cb38078cb62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the entire contents of the <em>source</em>  resource to the <em>dest</em> ination resource. Dimensions of the two resources have to match.  <a href="structreshade_1_1api_1_1command__list.html#a2f682681e028fbd85c57cb38078cb62a">More...</a><br /></td></tr>
<tr class="separator:a2f682681e028fbd85c57cb38078cb62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa7b61b5bf66f9e86a226e51076639a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a7aa7b61b5bf66f9e86a226e51076639a">copy_buffer_region</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> source, uint64_t source_offset, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> dest, uint64_t dest_offset, uint64_t size)=0</td></tr>
<tr class="memdesc:a7aa7b61b5bf66f9e86a226e51076639a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a linear memory region from the <em>source</em>  buffer to the <em>dest</em> ination buffer.  <a href="structreshade_1_1api_1_1command__list.html#a7aa7b61b5bf66f9e86a226e51076639a">More...</a><br /></td></tr>
<tr class="separator:a7aa7b61b5bf66f9e86a226e51076639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1777a04cdb5abe369a7d0f31a0f2f11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#aa1777a04cdb5abe369a7d0f31a0f2f11">copy_buffer_to_texture</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> source, uint64_t source_offset, uint32_t row_length, uint32_t slice_height, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> dest, uint32_t dest_subresource, const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *dest_box=nullptr)=0</td></tr>
<tr class="memdesc:aa1777a04cdb5abe369a7d0f31a0f2f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a texture region from the <em>source</em>  buffer to the <em>dest</em> ination texture.  <a href="structreshade_1_1api_1_1command__list.html#aa1777a04cdb5abe369a7d0f31a0f2f11">More...</a><br /></td></tr>
<tr class="separator:aa1777a04cdb5abe369a7d0f31a0f2f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab90d8d41f7c26d9dfcd87b8d99260d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#abab90d8d41f7c26d9dfcd87b8d99260d">copy_texture_region</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> source, uint32_t source_subresource, const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *source_box, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> dest, uint32_t dest_subresource, const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *dest_box, <a class="el" href="namespacereshade_1_1api.html#ae4674f12273e11e328bfd65fc827c384">filter_mode</a> filter=<a class="el" href="namespacereshade_1_1api.html#ae4674f12273e11e328bfd65fc827c384a61d050ff6497ed0a132fc6360ace094b">filter_mode::min_mag_mip_point</a>)=0</td></tr>
<tr class="memdesc:abab90d8d41f7c26d9dfcd87b8d99260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies or blits a texture region from the <em>source</em>  texture to the <em>dest</em> ination texture.  <a href="structreshade_1_1api_1_1command__list.html#abab90d8d41f7c26d9dfcd87b8d99260d">More...</a><br /></td></tr>
<tr class="separator:abab90d8d41f7c26d9dfcd87b8d99260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5cc3cda123a1c706d32f1034c03672"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a4e5cc3cda123a1c706d32f1034c03672">copy_texture_to_buffer</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> source, uint32_t source_subresource, const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *source_box, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> dest, uint64_t dest_offset, uint32_t row_length=0, uint32_t slice_height=0)=0</td></tr>
<tr class="memdesc:a4e5cc3cda123a1c706d32f1034c03672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a texture region from the <em>source</em>  texture to the <em>dest</em> ination buffer.  <a href="structreshade_1_1api_1_1command__list.html#a4e5cc3cda123a1c706d32f1034c03672">More...</a><br /></td></tr>
<tr class="separator:a4e5cc3cda123a1c706d32f1034c03672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af394fff6c8eec9430b2413994c68af77"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#af394fff6c8eec9430b2413994c68af77">resolve_texture_region</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> source, uint32_t source_subresource, const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *source_box, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> dest, uint32_t dest_subresource, int32_t dest_x, int32_t dest_y, int32_t dest_z, <a class="el" href="namespacereshade_1_1api.html#adbd317502610c902e7097163f5a9bb89">format</a> <a class="el" href="namespacereshade_1_1api.html#adbd317502610c902e7097163f5a9bb89">format</a>)=0</td></tr>
<tr class="memdesc:af394fff6c8eec9430b2413994c68af77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a region from the multisampled <em>source</em>  texture to the non-multisampled <em>dest</em> ination texture.  <a href="structreshade_1_1api_1_1command__list.html#af394fff6c8eec9430b2413994c68af77">More...</a><br /></td></tr>
<tr class="separator:af394fff6c8eec9430b2413994c68af77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec807b3414e0dbb540f9cc19a603003c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#aec807b3414e0dbb540f9cc19a603003c">clear_depth_stencil_view</a> (<a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> dsv, const float *depth, const uint8_t *stencil, uint32_t rect_count=0, const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *rects=nullptr)=0</td></tr>
<tr class="memdesc:aec807b3414e0dbb540f9cc19a603003c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the resource referenced by the depth-stencil view.  <a href="structreshade_1_1api_1_1command__list.html#aec807b3414e0dbb540f9cc19a603003c">More...</a><br /></td></tr>
<tr class="separator:aec807b3414e0dbb540f9cc19a603003c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c49db5bbfa3f9d2af9fc2104df088f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a45c49db5bbfa3f9d2af9fc2104df088f">clear_render_target_view</a> (<a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> rtv, const float color[4], uint32_t rect_count=0, const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *rects=nullptr)=0</td></tr>
<tr class="memdesc:a45c49db5bbfa3f9d2af9fc2104df088f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the resource referenced by the render target view.  <a href="structreshade_1_1api_1_1command__list.html#a45c49db5bbfa3f9d2af9fc2104df088f">More...</a><br /></td></tr>
<tr class="separator:a45c49db5bbfa3f9d2af9fc2104df088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14798fa8181e98fc629589802cf70c47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a14798fa8181e98fc629589802cf70c47">clear_unordered_access_view_uint</a> (<a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> uav, const uint32_t values[4], uint32_t rect_count=0, const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *rects=nullptr)=0</td></tr>
<tr class="memdesc:a14798fa8181e98fc629589802cf70c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the resource referenced by the unordered access view.  <a href="structreshade_1_1api_1_1command__list.html#a14798fa8181e98fc629589802cf70c47">More...</a><br /></td></tr>
<tr class="separator:a14798fa8181e98fc629589802cf70c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8b40c5878281418930c20dd1331f68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a1f8b40c5878281418930c20dd1331f68">clear_unordered_access_view_float</a> (<a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> uav, const float values[4], uint32_t rect_count=0, const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *rects=nullptr)=0</td></tr>
<tr class="memdesc:a1f8b40c5878281418930c20dd1331f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the resource referenced by the unordered access view.  <a href="structreshade_1_1api_1_1command__list.html#a1f8b40c5878281418930c20dd1331f68">More...</a><br /></td></tr>
<tr class="separator:a1f8b40c5878281418930c20dd1331f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab066738ef9831bba807081671846fea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#aab066738ef9831bba807081671846fea">generate_mipmaps</a> (<a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> srv)=0</td></tr>
<tr class="memdesc:aab066738ef9831bba807081671846fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the lower mipmap levels for the specified shader resource view. Uses the largest mipmap level of the view to recursively generate the lower levels of the mipmap chain and stops with the smallest level that is specified by the view.  <a href="structreshade_1_1api_1_1command__list.html#aab066738ef9831bba807081671846fea">More...</a><br /></td></tr>
<tr class="separator:aab066738ef9831bba807081671846fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77d2451ff23f728e6fbaf54558caf46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#ae77d2451ff23f728e6fbaf54558caf46">begin_query</a> (<a class="el" href="structreshade_1_1api_1_1query__heap.html">query_heap</a> heap, <a class="el" href="namespacereshade_1_1api.html#a12ac82b069d30cccaca8928394832bf1">query_type</a> type, uint32_t index)=0</td></tr>
<tr class="memdesc:ae77d2451ff23f728e6fbaf54558caf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a query.  <a href="structreshade_1_1api_1_1command__list.html#ae77d2451ff23f728e6fbaf54558caf46">More...</a><br /></td></tr>
<tr class="separator:ae77d2451ff23f728e6fbaf54558caf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dc0f67f96f6653d362bd33d58598ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#af4dc0f67f96f6653d362bd33d58598ce">end_query</a> (<a class="el" href="structreshade_1_1api_1_1query__heap.html">query_heap</a> heap, <a class="el" href="namespacereshade_1_1api.html#a12ac82b069d30cccaca8928394832bf1">query_type</a> type, uint32_t index)=0</td></tr>
<tr class="memdesc:af4dc0f67f96f6653d362bd33d58598ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a query.  <a href="structreshade_1_1api_1_1command__list.html#af4dc0f67f96f6653d362bd33d58598ce">More...</a><br /></td></tr>
<tr class="separator:af4dc0f67f96f6653d362bd33d58598ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8fab842fa82550d5cda7c7d64c296c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a9d8fab842fa82550d5cda7c7d64c296c">copy_query_heap_results</a> (<a class="el" href="structreshade_1_1api_1_1query__heap.html">query_heap</a> heap, <a class="el" href="namespacereshade_1_1api.html#a12ac82b069d30cccaca8928394832bf1">query_type</a> type, uint32_t first, uint32_t count, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> dest, uint64_t dest_offset, uint32_t stride)=0</td></tr>
<tr class="memdesc:a9d8fab842fa82550d5cda7c7d64c296c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the results of queries in a query heap to a buffer resource.  <a href="structreshade_1_1api_1_1command__list.html#a9d8fab842fa82550d5cda7c7d64c296c">More...</a><br /></td></tr>
<tr class="separator:a9d8fab842fa82550d5cda7c7d64c296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad2d3966e63018c8cb1aa8a2db1c2ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a5ad2d3966e63018c8cb1aa8a2db1c2ec">begin_debug_event</a> (const char *label, const float color[4]=nullptr)=0</td></tr>
<tr class="memdesc:a5ad2d3966e63018c8cb1aa8a2db1c2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a debug event region in the command list.  <a href="structreshade_1_1api_1_1command__list.html#a5ad2d3966e63018c8cb1aa8a2db1c2ec">More...</a><br /></td></tr>
<tr class="separator:a5ad2d3966e63018c8cb1aa8a2db1c2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e85530ee6c2c43eb0d3dfb256e6cc10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a4e85530ee6c2c43eb0d3dfb256e6cc10">end_debug_event</a> ()=0</td></tr>
<tr class="memdesc:a4e85530ee6c2c43eb0d3dfb256e6cc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the current debug event region (the last one opened with <a class="el" href="structreshade_1_1api_1_1command__list.html#a5ad2d3966e63018c8cb1aa8a2db1c2ec" title="Opens a debug event region in the command list.">begin_debug_event</a>).  <a href="structreshade_1_1api_1_1command__list.html#a4e85530ee6c2c43eb0d3dfb256e6cc10">More...</a><br /></td></tr>
<tr class="separator:a4e85530ee6c2c43eb0d3dfb256e6cc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa43b68ac312f25a8944e05166aa917"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a5aa43b68ac312f25a8944e05166aa917">insert_debug_marker</a> (const char *label, const float color[4]=nullptr)=0</td></tr>
<tr class="memdesc:a5aa43b68ac312f25a8944e05166aa917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug marker into the command list.  <a href="structreshade_1_1api_1_1command__list.html#a5aa43b68ac312f25a8944e05166aa917">More...</a><br /></td></tr>
<tr class="separator:a5aa43b68ac312f25a8944e05166aa917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b1812380688731b5ba0b0a448db58e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#aa5b1812380688731b5ba0b0a448db58e">dispatch_mesh</a> (uint32_t group_count_x, uint32_t group_count_y, uint32_t group_count_z)=0</td></tr>
<tr class="memdesc:aa5b1812380688731b5ba0b0a448db58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mesh shader dispatch.  <a href="structreshade_1_1api_1_1command__list.html#aa5b1812380688731b5ba0b0a448db58e">More...</a><br /></td></tr>
<tr class="separator:aa5b1812380688731b5ba0b0a448db58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0733f93fdfe14ae53323755d689ea8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a4a0733f93fdfe14ae53323755d689ea8">dispatch_rays</a> (<a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> raygen, uint64_t raygen_offset, uint64_t raygen_size, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> miss, uint64_t miss_offset, uint64_t miss_size, uint64_t miss_stride, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> hit_group, uint64_t hit_group_offset, uint64_t hit_group_size, uint64_t hit_group_stride, <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> callable, uint64_t callable_offset, uint64_t callable_size, uint64_t callable_stride, uint32_t width, uint32_t height, uint32_t depth)=0</td></tr>
<tr class="memdesc:a4a0733f93fdfe14ae53323755d689ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a ray tracing dispatch.  <a href="structreshade_1_1api_1_1command__list.html#a4a0733f93fdfe14ae53323755d689ea8">More...</a><br /></td></tr>
<tr class="separator:a4a0733f93fdfe14ae53323755d689ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9bbf9377777ba60d6bc12ab01782f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a7e9bbf9377777ba60d6bc12ab01782f5">copy_acceleration_structure</a> (<a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> source, <a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> dest, <a class="el" href="namespacereshade_1_1api.html#aa48a7127ac340d0b9bc058a5c31c67e7">acceleration_structure_copy_mode</a> mode)=0</td></tr>
<tr class="memdesc:a7e9bbf9377777ba60d6bc12ab01782f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies or transforms data from the <em>source</em>  acceleration structure to the <em>dest</em> ination acceleration structure.  <a href="structreshade_1_1api_1_1command__list.html#a7e9bbf9377777ba60d6bc12ab01782f5">More...</a><br /></td></tr>
<tr class="separator:a7e9bbf9377777ba60d6bc12ab01782f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06835f331c0b24b1da475d593c8fe4ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1command__list.html#a06835f331c0b24b1da475d593c8fe4ee">build_acceleration_structure</a> (<a class="el" href="namespacereshade_1_1api.html#a1ed6b36717133a7fcfde6ca974064f10">acceleration_structure_type</a> type, <a class="el" href="namespacereshade_1_1api.html#aa55963207d90079684f1dc9961dd15ea">acceleration_structure_build_flags</a> flags, uint32_t input_count, const <a class="el" href="structreshade_1_1api_1_1acceleration__structure__build__input.html">acceleration_structure_build_input</a> *inputs, <a class="el" href="structreshade_1_1api_1_1resource.html">api::resource</a> scratch, uint64_t scratch_offset, <a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> source, <a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> dest, <a class="el" href="namespacereshade_1_1api.html#a0f98490dc7498321a92b736be26e971e">acceleration_structure_build_mode</a> mode)=0</td></tr>
<tr class="memdesc:a06835f331c0b24b1da475d593c8fe4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds or updates an acceleration structure for ray tracing.  <a href="structreshade_1_1api_1_1command__list.html#a06835f331c0b24b1da475d593c8fe4ee">More...</a><br /></td></tr>
<tr class="separator:a06835f331c0b24b1da475d593c8fe4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structreshade_1_1api_1_1device__object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structreshade_1_1api_1_1device__object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structreshade_1_1api_1_1device__object.html">reshade::api::device_object</a></td></tr>
<tr class="memitem:a229e73b034269db13a8e2f483fc64ba3 inherit pub_methods_structreshade_1_1api_1_1device__object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structreshade_1_1api_1_1device.html">device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1device__object.html#a229e73b034269db13a8e2f483fc64ba3">get_device</a> ()=0</td></tr>
<tr class="memdesc:a229e73b034269db13a8e2f483fc64ba3 inherit pub_methods_structreshade_1_1api_1_1device__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent device for this object.  <a href="structreshade_1_1api_1_1device__object.html#a229e73b034269db13a8e2f483fc64ba3">More...</a><br /></td></tr>
<tr class="separator:a229e73b034269db13a8e2f483fc64ba3 inherit pub_methods_structreshade_1_1api_1_1device__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structreshade_1_1api_1_1api__object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structreshade_1_1api_1_1api__object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structreshade_1_1api_1_1api__object.html">reshade::api::api_object</a></td></tr>
<tr class="memitem:a4541f0b58f80f16dc6729858e42175a7 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1api__object.html#a4541f0b58f80f16dc6729858e42175a7">get_native</a> () const =0</td></tr>
<tr class="memdesc:a4541f0b58f80f16dc6729858e42175a7 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying native object for this API object.  <a href="structreshade_1_1api_1_1api__object.html#a4541f0b58f80f16dc6729858e42175a7">More...</a><br /></td></tr>
<tr class="separator:a4541f0b58f80f16dc6729858e42175a7 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4459480490de4a4f9ab5713317ac39ec inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1api__object.html#a4459480490de4a4f9ab5713317ac39ec">get_private_data</a> (const uint8_t guid[16], uint64_t *data) const =0</td></tr>
<tr class="memdesc:a4459480490de4a4f9ab5713317ac39ec inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a user-defined 64-bit value from the object that was previously set via <a class="el" href="structreshade_1_1api_1_1api__object.html#a62c6353765e5d7d017128f0acdfe1b9d" title="Stores a user-defined 64-bit value in the object and associates it with the specified guid .">set_private_data</a>, or zero if none associated with the specified <em>guid</em>  exists.  <a href="structreshade_1_1api_1_1api__object.html#a4459480490de4a4f9ab5713317ac39ec">More...</a><br /></td></tr>
<tr class="separator:a4459480490de4a4f9ab5713317ac39ec inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c6353765e5d7d017128f0acdfe1b9d inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1api__object.html#a62c6353765e5d7d017128f0acdfe1b9d">set_private_data</a> (const uint8_t guid[16], const uint64_t data)=0</td></tr>
<tr class="memdesc:a62c6353765e5d7d017128f0acdfe1b9d inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a user-defined 64-bit value in the object and associates it with the specified <em>guid</em> .  <a href="structreshade_1_1api_1_1api__object.html#a62c6353765e5d7d017128f0acdfe1b9d">More...</a><br /></td></tr>
<tr class="separator:a62c6353765e5d7d017128f0acdfe1b9d inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4ebd2b91dd992d2207712d612fe987 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea4ebd2b91dd992d2207712d612fe987 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1api__object.html#aea4ebd2b91dd992d2207712d612fe987">get_private_data</a> () const</td></tr>
<tr class="memdesc:aea4ebd2b91dd992d2207712d612fe987 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to user-defined data from the object that was previously allocated via <a class="el" href="structreshade_1_1api_1_1api__object.html#af0c46d2e179175fdfad869b5ee16ca11" title="Allocates user-defined data and stores it in the object.">create_private_data</a>.  <a href="structreshade_1_1api_1_1api__object.html#aea4ebd2b91dd992d2207712d612fe987">More...</a><br /></td></tr>
<tr class="separator:aea4ebd2b91dd992d2207712d612fe987 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c46d2e179175fdfad869b5ee16ca11 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af0c46d2e179175fdfad869b5ee16ca11 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1api__object.html#af0c46d2e179175fdfad869b5ee16ca11">create_private_data</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af0c46d2e179175fdfad869b5ee16ca11 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates user-defined data and stores it in the object.  <a href="structreshade_1_1api_1_1api__object.html#af0c46d2e179175fdfad869b5ee16ca11">More...</a><br /></td></tr>
<tr class="separator:af0c46d2e179175fdfad869b5ee16ca11 inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be856f3ade1bbe22f661830d688720d inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9be856f3ade1bbe22f661830d688720d inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structreshade_1_1api_1_1api__object.html#a9be856f3ade1bbe22f661830d688720d">destroy_private_data</a> ()</td></tr>
<tr class="memdesc:a9be856f3ade1bbe22f661830d688720d inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees user-defined data that was previously allocated via <a class="el" href="structreshade_1_1api_1_1api__object.html#af0c46d2e179175fdfad869b5ee16ca11" title="Allocates user-defined data and stores it in the object.">create_private_data</a>.  <a href="structreshade_1_1api_1_1api__object.html#a9be856f3ade1bbe22f661830d688720d">More...</a><br /></td></tr>
<tr class="separator:a9be856f3ade1bbe22f661830d688720d inherit pub_methods_structreshade_1_1api_1_1api__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A command list, used to enqueue render commands on the CPU, before later executing them in a command queue. </p>
<p>Functionally equivalent to a 'ID3D11CommandList', 'ID3D12CommandList' or 'VkCommandBuffer'.</p>
<p>This class may NOT be used concurrently from multiple threads! </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a73e3d799c04a6e232b707b0c49666c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e3d799c04a6e232b707b0c49666c73">&#9670;&nbsp;</a></span>barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reshade::api::command_list::barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a>&#160;</td>
          <td class="paramname"><em>old_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a>&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a barrier for the specified <em>resource</em>  to the command stream. When both <em>old_state</em>  and <em>new_state</em>  are <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a9d625a0527071357b9b7ba12d608c8cd">resource_usage::unordered_access</a> a UAV barrier is added, otherwise a state transition is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>Resource to transition.</td></tr>
    <tr><td class="paramname">old_state</td><td>Usage flags describing how the <em>resource</em>  was used before this barrier.</td></tr>
    <tr><td class="paramname">new_state</td><td>Usage flags describing how the <em>resource</em>  will be used after this barrier.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b1203d24668090d42df08ea2cc99bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1203d24668090d42df08ea2cc99bd7">&#9670;&nbsp;</a></span>barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::barrier </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> *&#160;</td>
          <td class="paramname"><em>resources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a> *&#160;</td>
          <td class="paramname"><em>old_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059">resource_usage</a> *&#160;</td>
          <td class="paramname"><em>new_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a barrier for the specified <em>resources</em>  to the command stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of resources to transition.</td></tr>
    <tr><td class="paramname">resources</td><td>Pointer to the first element of an array of resources to transition.</td></tr>
    <tr><td class="paramname">old_states</td><td>Pointer to the first element of an array of usage flags describing how the <em>resources</em>  were used before this barrier.</td></tr>
    <tr><td class="paramname">new_states</td><td>Pointer to the first element of an array of usage flags describing how the <em>resources</em>  will be used after this barrier.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ad2d3966e63018c8cb1aa8a2db1c2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad2d3966e63018c8cb1aa8a2db1c2ec">&#9670;&nbsp;</a></span>begin_debug_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::begin_debug_event </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>color</em>[4] = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a debug event region in the command list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Null-terminated string containing the label of the event.</td></tr>
    <tr><td class="paramname">color</td><td>Optional RGBA color value associated with the event.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae77d2451ff23f728e6fbaf54558caf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77d2451ff23f728e6fbaf54558caf46">&#9670;&nbsp;</a></span>begin_query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::begin_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1query__heap.html">query_heap</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a12ac82b069d30cccaca8928394832bf1">query_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Query heap that will manage the results of the query.</td></tr>
    <tr><td class="paramname">type</td><td>Type of the query to begin.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the query in the query heap.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75b9644e936983d75ca1244150c7f956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b9644e936983d75ca1244150c7f956">&#9670;&nbsp;</a></span>begin_render_pass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::begin_render_pass </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1render__pass__render__target__desc.html">render_pass_render_target_desc</a> *&#160;</td>
          <td class="paramname"><em>rts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1render__pass__depth__stencil__desc.html">render_pass_depth_stencil_desc</a> *&#160;</td>
          <td class="paramname"><em>ds</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a render pass and binds render target and depth-stencil resource views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of render target views to bind.</td></tr>
    <tr><td class="paramname">rts</td><td>Pointer to the first element of an array of render target descriptions.</td></tr>
    <tr><td class="paramname">ds</td><td>Optional pointer to a depth-stencil description, or <code>nullptr</code> to bind none.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8266f2bdeeaea48e6497ed8aff127e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8266f2bdeeaea48e6497ed8aff127e65">&#9670;&nbsp;</a></span>bind_descriptor_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reshade::api::command_list::bind_descriptor_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a>&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1descriptor__table.html">descriptor_table</a>&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a single descriptor table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stages</td><td>Shader stages that will use the descriptors.</td></tr>
    <tr><td class="paramname">layout</td><td>Pipeline layout that describes the descriptors.</td></tr>
    <tr><td class="paramname">param</td><td>Index of the pipeline <em>layout</em>  parameter that describes the descriptor table (root parameter index in D3D12, descriptor set index in Vulkan).</td></tr>
    <tr><td class="paramname">table</td><td>Descriptor table to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace034fd1770ba272768d779c62300174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace034fd1770ba272768d779c62300174">&#9670;&nbsp;</a></span>bind_descriptor_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_descriptor_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a>&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1descriptor__table.html">descriptor_table</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an array of descriptor tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stages</td><td>Shader stages that will use the descriptors.</td></tr>
    <tr><td class="paramname">layout</td><td>Pipeline layout that describes the descriptors.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first pipeline <em>layout</em>  parameter that describes the first descriptor table to bind (root parameter index in D3D12, descriptor set index in Vulkan).</td></tr>
    <tr><td class="paramname">count</td><td>Number of descriptor tables to bind.</td></tr>
    <tr><td class="paramname">tables</td><td>Pointer to the first element of an array of descriptor tables to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aa24a66cda78ff105d1975a297e4314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa24a66cda78ff105d1975a297e4314">&#9670;&nbsp;</a></span>bind_index_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_index_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an index buffer to the input-assembler stage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Index buffer resource. This resource must have been created with the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059aab150dddbaa3966d354cc6dcd7418ea9">resource_usage::index_buffer</a> usage.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) from the start of the index buffer to the first index to use. In D3D9 this has to be 0.</td></tr>
    <tr><td class="paramname">index_size</td><td>Size (in bytes) of each index. Can typically be 2 (16-bit indices) or 4 (32-bit indices).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbc22fd6a89454e4ac11497d8290e1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc22fd6a89454e4ac11497d8290e1b2">&#9670;&nbsp;</a></span>bind_pipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_pipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a46a70b7dcd8b1e829ff8102091b64037">pipeline_stage</a>&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1pipeline.html">pipeline</a>&#160;</td>
          <td class="paramname"><em>pipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a pipeline state object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stages</td><td>Pipeline stages to update with state from the pipeline state object.</td></tr>
    <tr><td class="paramname">pipeline</td><td>Pipeline state object to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a804b3aa8c3f0e465e98762c27fc75798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804b3aa8c3f0e465e98762c27fc75798">&#9670;&nbsp;</a></span>bind_pipeline_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reshade::api::command_list::bind_pipeline_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a21e917814c5dd21aa28d2e6564f504d9">dynamic_state</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the specfified pipeline <em>state</em>  to the specified <em>value</em> . This is only valid for states that have been listed in the dynamic states provided at creation of the currently bound pipeline state object (<a class="el" href="namespacereshade_1_1api.html#ad62e21a3e52b83de83ad42ca5bebbd6aa56009880edb86cf5e2b83dc674625123" title="States that may be dynamically updated via command_list::bind_pipeline_states after binding this pipe...">pipeline_subobject_type::dynamic_pipeline_states</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pipeline state to update.</td></tr>
    <tr><td class="paramname">value</td><td>Value to update the pipeline state to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4457eb23164ccfe161c39e2eba2a928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4457eb23164ccfe161c39e2eba2a928">&#9670;&nbsp;</a></span>bind_pipeline_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_pipeline_states </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacereshade_1_1api.html#a21e917814c5dd21aa28d2e6564f504d9">dynamic_state</a> *&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the specfified pipeline <em>states</em>  to the specified <em>values</em> . This is only valid for states that have been listed in the dynamic states provided at creation of the currently bound pipeline state object (<a class="el" href="namespacereshade_1_1api.html#ad62e21a3e52b83de83ad42ca5bebbd6aa56009880edb86cf5e2b83dc674625123" title="States that may be dynamically updated via command_list::bind_pipeline_states after binding this pipe...">pipeline_subobject_type::dynamic_pipeline_states</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of pipeline states to update.</td></tr>
    <tr><td class="paramname">states</td><td>Pointer to the first element of an array of pipeline states to update.</td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the first element of an array of values to update the pipeline states to, with one for each state in <em>states</em> .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b5bd17b2cb03863913efda6e01d972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b5bd17b2cb03863913efda6e01d972">&#9670;&nbsp;</a></span>bind_render_targets_and_depth_stencil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_render_targets_and_depth_stencil </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a> *&#160;</td>
          <td class="paramname"><em>rtvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>dsv</em> = <code>{&#160;0&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds individual render target and depth-stencil resource views. This must not be called between <a class="el" href="structreshade_1_1api_1_1command__list.html#a75b9644e936983d75ca1244150c7f956" title="Begins a render pass and binds render target and depth-stencil resource views.">begin_render_pass</a> and <a class="el" href="structreshade_1_1api_1_1command__list.html#a4e7e0b86b35be07c2e03a2ea19843ace" title="Ends a render pass. This must be preceeded by a call to begin_render_pass. Render passes cannot be ne...">end_render_pass</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a987b2aa4a2dd7ad21a312488fe3cf9db" title="Specifies whether binding individual render target and depth-stencil resource views is supported....">device_caps::bind_render_targets_and_depth_stencil</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Number of render target views to bind.</td></tr>
    <tr><td class="paramname">rtvs</td><td>Pointer to the first element of an array of render target views to bind.</td></tr>
    <tr><td class="paramname">dsv</td><td>Depth-stencil view to bind, or zero to bind none.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84688340495260d6634bfe2247bb0a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84688340495260d6634bfe2247bb0a34">&#9670;&nbsp;</a></span>bind_scissor_rects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_scissor_rects </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *&#160;</td>
          <td class="paramname"><em>rects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an array of scissor rectangles to the rasterizer stage. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a4e134cc959165e70f2e8152111b941c6" title="Specifies whther more than one viewport is supported. If this feature is not present,...">device_caps::multi_viewport</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Index of the first scissor rectangle to bind. In D3D9, D3D10, D3D11 and D3D12 this has to be 0.</td></tr>
    <tr><td class="paramname">count</td><td>Number of scissor rectangles to bind.</td></tr>
    <tr><td class="paramname">rects</td><td>Pointer to the first element of an array of scissor rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b5be175dacc3ea67f6bed6801ff2676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5be175dacc3ea67f6bed6801ff2676">&#9670;&nbsp;</a></span>bind_stream_output_buffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_stream_output_buffers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1resource.html">api::resource</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>max_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1resource.html">api::resource</a> *&#160;</td>
          <td class="paramname"><em>counter_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>counter_offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an array of buffers to the stream-output stage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First stream-output slot for binding.</td></tr>
    <tr><td class="paramname">count</td><td>Number of stream-output targets to bind.</td></tr>
    <tr><td class="paramname">buffers</td><td>Pointer to the first element of an array of buffer resources. These resources must have been created with the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059ae87dd9ecbaae1056b5941e6e1f4645a1">resource_usage::stream_output</a> usage.</td></tr>
    <tr><td class="paramname">offsets</td><td>Pointer to the first element of an array of offset values, one for each buffer. Each offset is the number of bytes from the start of the buffer to the first element to write to.</td></tr>
    <tr><td class="paramname">max_sizes</td><td>Optional pointer to an array of size values, one for each buffer. Can be <code>nullptr</code> or have elements set to UINT64_MAX to use the entire buffer.</td></tr>
    <tr><td class="paramname">counter_buffers</td><td>Pointer to the first element of an array of counter buffer resources. These resources must have been created with the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059ae87dd9ecbaae1056b5941e6e1f4645a1">resource_usage::stream_output</a> usage.</td></tr>
    <tr><td class="paramname">counter_offsets</td><td>Pointer to the first element of an array of counter offset values, one for each counter buffer. Each offset is the number of bytes from the start of the counter buffer to the first element to write to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8618e997b035a86daa8c7c9357af90a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8618e997b035a86daa8c7c9357af90a6">&#9670;&nbsp;</a></span>bind_vertex_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reshade::api::command_list::bind_vertex_buffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a single vertex buffer to the input-assembler stage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Input slot for binding.</td></tr>
    <tr><td class="paramname">buffer</td><td>Vertex buffer resource. This resources must have been created with the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a9a89a832efcc2557585b289cc295f7f5">resource_usage::vertex_buffer</a> usage.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) from the start of the vertex buffer to the first vertex element to use.</td></tr>
    <tr><td class="paramname">stride</td><td>Size (in bytes) of the vertex element that will be used from the vertex buffer (is added to an element offset to advance to the next).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a199bb68035b8cc0a70b3335d8eea545d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199bb68035b8cc0a70b3335d8eea545d">&#9670;&nbsp;</a></span>bind_vertex_buffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_vertex_buffers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1resource.html">resource</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an array of vertex buffers to the input-assembler stage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First input slot for binding.</td></tr>
    <tr><td class="paramname">count</td><td>Number of vertex buffers to bind.</td></tr>
    <tr><td class="paramname">buffers</td><td>Pointer to the first element of an array of vertex buffer resources. These resources must have been created with the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a9a89a832efcc2557585b289cc295f7f5">resource_usage::vertex_buffer</a> usage.</td></tr>
    <tr><td class="paramname">offsets</td><td>Pointer to the first element of an array of offset values, one for each buffer. Each offset is the number of bytes from the start of the vertex buffer to the first vertex element to use.</td></tr>
    <tr><td class="paramname">strides</td><td>Pointer to the first element of an array of stride values, one for each buffer. Each stride is the size (in bytes) of the vertex element that will be used from that vertex buffer (is added to an element offset to advance to the next).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a557b2f95f05e3d05a8cf02bbd199cf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557b2f95f05e3d05a8cf02bbd199cf5a">&#9670;&nbsp;</a></span>bind_viewports()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::bind_viewports </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1viewport.html">viewport</a> *&#160;</td>
          <td class="paramname"><em>viewports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds an array of viewports to the rasterizer stage. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a4e134cc959165e70f2e8152111b941c6" title="Specifies whther more than one viewport is supported. If this feature is not present,...">device_caps::multi_viewport</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Index of the first viewport to bind. In D3D9, D3D10, D3D11 and D3D12 this has to be 0.</td></tr>
    <tr><td class="paramname">count</td><td>Number of viewports to bind.</td></tr>
    <tr><td class="paramname">viewports</td><td>Pointer to the first element of an array of viewports.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06835f331c0b24b1da475d593c8fe4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06835f331c0b24b1da475d593c8fe4ee">&#9670;&nbsp;</a></span>build_acceleration_structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::build_acceleration_structure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a1ed6b36717133a7fcfde6ca974064f10">acceleration_structure_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#aa55963207d90079684f1dc9961dd15ea">acceleration_structure_build_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>input_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1acceleration__structure__build__input.html">acceleration_structure_build_input</a> *&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">api::resource</a>&#160;</td>
          <td class="paramname"><em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>scratch_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a0f98490dc7498321a92b736be26e971e">acceleration_structure_build_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds or updates an acceleration structure for ray tracing. </p>
<p>The build input vertex, index and instance buffers have to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a97db02b34da459bb88908c0c81ea3ac8">resource_usage::shader_resource_non_pixel</a> state. The <em>scratch</em>  resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a9d625a0527071357b9b7ba12d608c8cd">resource_usage::unordered_access</a> state. The <em>source</em>  and <em>dest</em> ination acceleration structure resources have to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a5ce48948fe80f65f45fa4ecebbdc867c">resource_usage::acceleration_structure</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0ab81ff79cf4b62f6bb20b890dacfd241c" title="Specifies whether ray tracing is supported. If this feature is not present, resource_view_type::accel...">device_caps::ray_tracing</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of the acceleration structure to build.</td></tr>
    <tr><td class="paramname">flags</td><td>Acceleration structure build options.</td></tr>
    <tr><td class="paramname">input_count</td><td>Number of build inputs.</td></tr>
    <tr><td class="paramname">inputs</td><td>Pointer to the first element of an array of build inputs describing the geometry of the acceleration structure to build.</td></tr>
    <tr><td class="paramname">scratch</td><td>Buffer resource to use as scratch space during building.</td></tr>
    <tr><td class="paramname">scratch_offset</td><td>Offset (in bytes) into the <em>scratch</em>  buffer.</td></tr>
    <tr><td class="paramname">source</td><td>Acceleration structure to read data from when <em>mode</em>  is <a class="el" href="namespacereshade_1_1api.html#a0f98490dc7498321a92b736be26e971ea3ac340832f29c11538fbe2d6f75e8bcc">acceleration_structure_build_mode::update</a>, otherwise zero.</td></tr>
    <tr><td class="paramname">dest</td><td>Acceleration structure to write data to.</td></tr>
    <tr><td class="paramname">mode</td><td>Choose between building a new or updating an existing acceleration structure.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec807b3414e0dbb540f9cc19a603003c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec807b3414e0dbb540f9cc19a603003c">&#9670;&nbsp;</a></span>clear_depth_stencil_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::clear_depth_stencil_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>dsv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rect_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *&#160;</td>
          <td class="paramname"><em>rects</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the resource referenced by the depth-stencil view. </p>
<p>The resource the depth-stencil view points to has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a8d67848e47e92b279f252dd3f27969cd">resource_usage::depth_stencil_write</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsv</td><td>Resource view handle of the depth-stencil.</td></tr>
    <tr><td class="paramname">depth</td><td>Optional value to clear the depth buffer with.</td></tr>
    <tr><td class="paramname">stencil</td><td>Optional value to clear the stencil buffer with.</td></tr>
    <tr><td class="paramname">rect_count</td><td>Number of rectangles to clear in the depth-stencil resource, or zero to clear the whole resource.</td></tr>
    <tr><td class="paramname">rects</td><td>Pointer to the first element of an array of rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45c49db5bbfa3f9d2af9fc2104df088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c49db5bbfa3f9d2af9fc2104df088f">&#9670;&nbsp;</a></span>clear_render_target_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::clear_render_target_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>rtv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>color</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rect_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *&#160;</td>
          <td class="paramname"><em>rects</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the resource referenced by the render target view. </p>
<p>The resource the render target view points to has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059ad45c5bd809b1fc46e5f3a29c44acde8d">resource_usage::render_target</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtv</td><td>Resource view handle of the render target.</td></tr>
    <tr><td class="paramname">color</td><td>Value to clear the resource with.</td></tr>
    <tr><td class="paramname">rect_count</td><td>Number of rectangles to clear in the render target resource, or zero to clear the whole resource.</td></tr>
    <tr><td class="paramname">rects</td><td>Pointer to the first element of an array of rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f8b40c5878281418930c20dd1331f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8b40c5878281418930c20dd1331f68">&#9670;&nbsp;</a></span>clear_unordered_access_view_float()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::clear_unordered_access_view_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>uav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>values</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rect_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *&#160;</td>
          <td class="paramname"><em>rects</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the resource referenced by the unordered access view. </p>
<p>The resource the unordered access view points to has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a9d625a0527071357b9b7ba12d608c8cd">resource_usage::unordered_access</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uav</td><td>Resource view handle of the unordered access view.</td></tr>
    <tr><td class="paramname">values</td><td>Value to clear the resource with.</td></tr>
    <tr><td class="paramname">rect_count</td><td>Number of rectangles to clear in the unordered access resource, or zero to clear the whole resource.</td></tr>
    <tr><td class="paramname">rects</td><td>Pointer to the first element of an array of rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14798fa8181e98fc629589802cf70c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14798fa8181e98fc629589802cf70c47">&#9670;&nbsp;</a></span>clear_unordered_access_view_uint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::clear_unordered_access_view_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>uav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>values</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rect_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1rect.html">rect</a> *&#160;</td>
          <td class="paramname"><em>rects</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the resource referenced by the unordered access view. </p>
<p>The resource the unordered access view points to has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a9d625a0527071357b9b7ba12d608c8cd">resource_usage::unordered_access</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uav</td><td>Resource view handle of the unordered access view.</td></tr>
    <tr><td class="paramname">values</td><td>Value to clear the resource with.</td></tr>
    <tr><td class="paramname">rect_count</td><td>Number of rectangles to clear in the unordered access resource, or zero to clear the whole resource.</td></tr>
    <tr><td class="paramname">rects</td><td>Pointer to the first element of an array of rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e9bbf9377777ba60d6bc12ab01782f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9bbf9377777ba60d6bc12ab01782f5">&#9670;&nbsp;</a></span>copy_acceleration_structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::copy_acceleration_structure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#aa48a7127ac340d0b9bc058a5c31c67e7">acceleration_structure_copy_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies or transforms data from the <em>source</em>  acceleration structure to the <em>dest</em> ination acceleration structure. </p>
<p>The <em>source</em>  and <em>dest</em> ination acceleration structure resources have to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a5ce48948fe80f65f45fa4ecebbdc867c">resource_usage::acceleration_structure</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0ab81ff79cf4b62f6bb20b890dacfd241c" title="Specifies whether ray tracing is supported. If this feature is not present, resource_view_type::accel...">device_caps::ray_tracing</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Acceleration structure to copy from.</td></tr>
    <tr><td class="paramname">dest</td><td>Acceleration structure to copy to.</td></tr>
    <tr><td class="paramname">mode</td><td>Choose between copying or transforming the data in the acceleration structure.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aa7b61b5bf66f9e86a226e51076639a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa7b61b5bf66f9e86a226e51076639a">&#9670;&nbsp;</a></span>copy_buffer_region()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::copy_buffer_region </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>source_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>dest_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a linear memory region from the <em>source</em>  buffer to the <em>dest</em> ination buffer. </p>
<p>The <em>source</em>  resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a751fdad2b83af8ed443d3c2d6efd7822">resource_usage::copy_source</a> state. The <em>dest</em> ination resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a3a20bc63470d18df9ac2b7163b5d89f6">resource_usage::copy_dest</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a80257d98cf24fac3db951337ebad0423" title="Specifies whether copying between buffers is supported. If this feature is not present,...">device_caps::copy_buffer_region</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Buffer resource to copy from.</td></tr>
    <tr><td class="paramname">source_offset</td><td>Offset (in bytes) into the <em>source</em>  buffer to start copying at.</td></tr>
    <tr><td class="paramname">dest</td><td>Buffer resource to copy to.</td></tr>
    <tr><td class="paramname">dest_offset</td><td>Offset (in bytes) into the <em>dest</em> ination buffer to start copying to.</td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1777a04cdb5abe369a7d0f31a0f2f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1777a04cdb5abe369a7d0f31a0f2f11">&#9670;&nbsp;</a></span>copy_buffer_to_texture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::copy_buffer_to_texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>source_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>row_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slice_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dest_subresource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *&#160;</td>
          <td class="paramname"><em>dest_box</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a texture region from the <em>source</em>  buffer to the <em>dest</em> ination texture. </p>
<p>The <em>source</em>  resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a751fdad2b83af8ed443d3c2d6efd7822">resource_usage::copy_source</a> state. The <em>dest</em> ination resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a3a20bc63470d18df9ac2b7163b5d89f6">resource_usage::copy_dest</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0aad18153d559de9119fdc4802cc36b681" title="Specifies whether copying between buffers and textures is supported. If this feature is not present,...">device_caps::copy_buffer_to_texture</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Buffer resource to copy from.</td></tr>
    <tr><td class="paramname">source_offset</td><td>Offset (in bytes) into the <em>source</em>  buffer to start copying at.</td></tr>
    <tr><td class="paramname">row_length</td><td>Number of pixels from one row to the next (in the buffer), or zero if data is tightly packed.</td></tr>
    <tr><td class="paramname">slice_height</td><td>Number of rows from one slice to the next (in the buffer) or zero if data is tightly packed.</td></tr>
    <tr><td class="paramname">dest</td><td>Texture resource to copy to.</td></tr>
    <tr><td class="paramname">dest_subresource</td><td>Index of the subresource of the <em>dest</em> ination texture to copy to.</td></tr>
    <tr><td class="paramname">dest_box</td><td>Optional 3D box (or <code>nullptr</code> to reference the entire subresource) that defines the region in the <em>dest</em> ination texture to copy to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d8fab842fa82550d5cda7c7d64c296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8fab842fa82550d5cda7c7d64c296c">&#9670;&nbsp;</a></span>copy_query_heap_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::copy_query_heap_results </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1query__heap.html">query_heap</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a12ac82b069d30cccaca8928394832bf1">query_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>dest_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the results of queries in a query heap to a buffer resource. </p>
<p>The <em>dest</em> ination resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a3a20bc63470d18df9ac2b7163b5d89f6">resource_usage::copy_dest</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0ae487ba2c9be37695c211184efc8d76a4" title="Specifies whether copying query results to a buffer is supported. If this feature is not present,...">device_caps::copy_query_heap_results</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Query heap that manages the results of the queries.</td></tr>
    <tr><td class="paramname">type</td><td>Type of the queries to copy.</td></tr>
    <tr><td class="paramname">first</td><td>Index of the first query in the query heap to copy the result from.</td></tr>
    <tr><td class="paramname">count</td><td>Number of query results to copy.</td></tr>
    <tr><td class="paramname">dest</td><td>Buffer resource to copy to.</td></tr>
    <tr><td class="paramname">dest_offset</td><td>Offset (in bytes) into the <em>dest</em> ination buffer to start copying to.</td></tr>
    <tr><td class="paramname">stride</td><td>Size (in bytes) of each result element.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f682681e028fbd85c57cb38078cb62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f682681e028fbd85c57cb38078cb62a">&#9670;&nbsp;</a></span>copy_resource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::copy_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the entire contents of the <em>source</em>  resource to the <em>dest</em> ination resource. Dimensions of the two resources have to match. </p>
<p>The <em>source</em>  resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a751fdad2b83af8ed443d3c2d6efd7822">resource_usage::copy_source</a> state. The <em>dest</em> ination resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a3a20bc63470d18df9ac2b7163b5d89f6">resource_usage::copy_dest</a> state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Resource to copy from.</td></tr>
    <tr><td class="paramname">dest</td><td>Resource to copy to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abab90d8d41f7c26d9dfcd87b8d99260d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab90d8d41f7c26d9dfcd87b8d99260d">&#9670;&nbsp;</a></span>copy_texture_region()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::copy_texture_region </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>source_subresource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *&#160;</td>
          <td class="paramname"><em>source_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dest_subresource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *&#160;</td>
          <td class="paramname"><em>dest_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#ae4674f12273e11e328bfd65fc827c384">filter_mode</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="namespacereshade_1_1api.html#ae4674f12273e11e328bfd65fc827c384a61d050ff6497ed0a132fc6360ace094b">filter_mode::min_mag_mip_point</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies or blits a texture region from the <em>source</em>  texture to the <em>dest</em> ination texture. </p>
<p>The <em>source</em>  resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a751fdad2b83af8ed443d3c2d6efd7822">resource_usage::copy_source</a> state. The <em>dest</em> ination resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a3a20bc63470d18df9ac2b7163b5d89f6">resource_usage::copy_dest</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0ae120bede29a8f2b624d7f55078d7a15f" title="Specifies whether blitting between resources is supported. If this feature is not present,...">device_caps::blit</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Texture resource to copy from.</td></tr>
    <tr><td class="paramname">source_subresource</td><td>Index of the subresource of the <em>source</em>  texture to copy from.</td></tr>
    <tr><td class="paramname">source_box</td><td>Optional 3D box (or <code>nullptr</code> to reference the entire subresource) that defines the region in the <em>source</em>  texture to blit from.</td></tr>
    <tr><td class="paramname">dest</td><td>Texture resource to copy to.</td></tr>
    <tr><td class="paramname">dest_subresource</td><td>Index of the subresource of the <em>dest</em> ination texture to copy to.</td></tr>
    <tr><td class="paramname">dest_box</td><td>Optional 3D box (or <code>nullptr</code> to reference the entire subresource) that defines the region in the <em>dest</em> ination texture to blit to.</td></tr>
    <tr><td class="paramname">filter</td><td>Filter to apply when copy requires scaling.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5cc3cda123a1c706d32f1034c03672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5cc3cda123a1c706d32f1034c03672">&#9670;&nbsp;</a></span>copy_texture_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::copy_texture_to_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>source_subresource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *&#160;</td>
          <td class="paramname"><em>source_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>dest_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>row_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slice_height</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a texture region from the <em>source</em>  texture to the <em>dest</em> ination buffer. </p>
<p>The <em>source</em>  resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a751fdad2b83af8ed443d3c2d6efd7822">resource_usage::copy_source</a> state. The <em>dest</em> ination resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a3a20bc63470d18df9ac2b7163b5d89f6">resource_usage::copy_dest</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0aad18153d559de9119fdc4802cc36b681" title="Specifies whether copying between buffers and textures is supported. If this feature is not present,...">device_caps::copy_buffer_to_texture</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Texture resource to copy from.</td></tr>
    <tr><td class="paramname">source_subresource</td><td>Index of the subresource of the <em>source</em>  texture to copy from.</td></tr>
    <tr><td class="paramname">source_box</td><td>Optional 3D box (or <code>nullptr</code> to reference the entire subresource) that defines the region in the <em>source</em>  texture to copy from.</td></tr>
    <tr><td class="paramname">dest</td><td>Buffer resource to copy to.</td></tr>
    <tr><td class="paramname">dest_offset</td><td>Offset (in bytes) into the <em>dest</em> ination buffer to start copying to.</td></tr>
    <tr><td class="paramname">row_length</td><td>Number of pixels from one row to the next (in the buffer), or zero if data is tightly packed.</td></tr>
    <tr><td class="paramname">slice_height</td><td>Number of rows from one slice to the next (in the buffer), or zero if data is tightly packed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d1b3d51f9849f69e9c3819a89751b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1b3d51f9849f69e9c3819a89751b9e">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::dispatch </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_count_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_count_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_count_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a compute shader dispatch. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a3fab409c137d7ba5f6c7cf647a3d3d62" title="Specifies whether compute shaders are supported. If this feature is not present, the pipeline_stage::...">device_caps::compute_shader</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_count_x</td><td>Number of thread groups dispatched in the x direction.</td></tr>
    <tr><td class="paramname">group_count_y</td><td>Number of thread groups dispatched in the y direction.</td></tr>
    <tr><td class="paramname">group_count_z</td><td>Number of thread groups dispatched in the z direction.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5b1812380688731b5ba0b0a448db58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b1812380688731b5ba0b0a448db58e">&#9670;&nbsp;</a></span>dispatch_mesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::dispatch_mesh </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_count_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_count_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>group_count_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a mesh shader dispatch. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0afd742c2f459732c8964d921484a22038" title="Specifies whether amplification and mesh shaders are supported. If this feature is not present,...">device_caps::amplification_and_mesh_shader</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_count_x</td><td>Number of thread groups dispatched in the x direction.</td></tr>
    <tr><td class="paramname">group_count_y</td><td>Number of thread groups dispatched in the y direction.</td></tr>
    <tr><td class="paramname">group_count_z</td><td>Number of thread groups dispatched in the z direction.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a0733f93fdfe14ae53323755d689ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0733f93fdfe14ae53323755d689ea8">&#9670;&nbsp;</a></span>dispatch_rays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::dispatch_rays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>raygen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>raygen_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>raygen_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>miss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>miss_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>miss_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>miss_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>hit_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>hit_group_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>hit_group_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>hit_group_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>callable_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>callable_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>callable_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a ray tracing dispatch. </p>
<p>The buffer resources have to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a97db02b34da459bb88908c0c81ea3ac8">resource_usage::shader_resource_non_pixel</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0ab81ff79cf4b62f6bb20b890dacfd241c" title="Specifies whether ray tracing is supported. If this feature is not present, resource_view_type::accel...">device_caps::ray_tracing</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raygen</td><td>Buffer resource containing the ray generation shader handle to use.</td></tr>
    <tr><td class="paramname">miss</td><td>Buffer resource containing the miss shader handles to use.</td></tr>
    <tr><td class="paramname">hit_group</td><td>Buffer resource containing the hit group handles to use.</td></tr>
    <tr><td class="paramname">callable</td><td>Buffer resource containing the callable shader handles to use.</td></tr>
    <tr><td class="paramname">width</td><td>Width of the ray generation shader thread grid.</td></tr>
    <tr><td class="paramname">height</td><td>Height of the ray generation shader thread grid.</td></tr>
    <tr><td class="paramname">depth</td><td>Depth of the ray generation shader thread grid.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1979928ce2b057d783fab63efab846b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1979928ce2b057d783fab63efab846b0">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::draw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vertex_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws non-indexed primitives. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0afac290d641e57a4ab6d0a086ceba380d" title="Specifies whether instancing is supported. If this feature is not present, the &quot;instance_count&quot; and &quot;...">device_caps::draw_instanced</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_count</td><td>Number of vertices to draw.</td></tr>
    <tr><td class="paramname">instance_count</td><td>Number of instances to draw. In D3D9 this has to be 1.</td></tr>
    <tr><td class="paramname">first_vertex</td><td>Index of the first vertex.</td></tr>
    <tr><td class="paramname">first_instance</td><td>Value added to each index before reading per-instance data from a vertex buffer. In D3D9 this has to be 0.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc63fba83dae2e56c79eb79bc3b3820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc63fba83dae2e56c79eb79bc3b3820e">&#9670;&nbsp;</a></span>draw_indexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::draw_indexed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>vertex_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws indexed primitives. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0afac290d641e57a4ab6d0a086ceba380d" title="Specifies whether instancing is supported. If this feature is not present, the &quot;instance_count&quot; and &quot;...">device_caps::draw_instanced</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_count</td><td>Number of indices read from the index buffer for each instance.</td></tr>
    <tr><td class="paramname">instance_count</td><td>Number of instances to draw. In D3D9 this has to be 1.</td></tr>
    <tr><td class="paramname">first_index</td><td>Location of the first index read from the index buffer.</td></tr>
    <tr><td class="paramname">vertex_offset</td><td>Value added to each index before reading per-vertex data from a vertex buffer.</td></tr>
    <tr><td class="paramname">first_instance</td><td>Value added to each index before reading per-instance data from a vertex buffer. In D3D9 this has to be 0.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85bbf10afa86718f636a431910ddb0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bbf10afa86718f636a431910ddb0f4">&#9670;&nbsp;</a></span>draw_or_dispatch_indirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::draw_or_dispatch_indirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a4d43e282e1516074653731962281d7a1">indirect_command</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>draw_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes indirect draw or dispatch commands. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a3299ec3835b4d48e817b73a6051b5055" title="Specifies whether indirect draw or dispatch calls are supported. If this feature is not present,...">device_caps::draw_or_dispatch_indirect</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies whether this is an indirect draw, indexed draw or dispatch command.</td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer resource that contains command arguments.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) from the start of the argument buffer to the first argument to use.</td></tr>
    <tr><td class="paramname">draw_count</td><td>Number of commands to execute.</td></tr>
    <tr><td class="paramname">stride</td><td>Stride (in bytes) between commands in the argument buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e85530ee6c2c43eb0d3dfb256e6cc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e85530ee6c2c43eb0d3dfb256e6cc10">&#9670;&nbsp;</a></span>end_debug_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::end_debug_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the current debug event region (the last one opened with <a class="el" href="structreshade_1_1api_1_1command__list.html#a5ad2d3966e63018c8cb1aa8a2db1c2ec" title="Opens a debug event region in the command list.">begin_debug_event</a>). </p>

</div>
</div>
<a id="af4dc0f67f96f6653d362bd33d58598ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4dc0f67f96f6653d362bd33d58598ce">&#9670;&nbsp;</a></span>end_query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::end_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1query__heap.html">query_heap</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#a12ac82b069d30cccaca8928394832bf1">query_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Query heap that will manage the results of the query.</td></tr>
    <tr><td class="paramname">type</td><td>Type of the query end.</td></tr>
    <tr><td class="paramname">index</td><td>Index of the query in the query heap.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e7e0b86b35be07c2e03a2ea19843ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7e0b86b35be07c2e03a2ea19843ace">&#9670;&nbsp;</a></span>end_render_pass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::end_render_pass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a render pass. This must be preceeded by a call to <a class="el" href="structreshade_1_1api_1_1command__list.html#a75b9644e936983d75ca1244150c7f956" title="Begins a render pass and binds render target and depth-stencil resource views.">begin_render_pass</a>. Render passes cannot be nested. </p>

</div>
</div>
<a id="aab066738ef9831bba807081671846fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab066738ef9831bba807081671846fea">&#9670;&nbsp;</a></span>generate_mipmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::generate_mipmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource__view.html">resource_view</a>&#160;</td>
          <td class="paramname"><em>srv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the lower mipmap levels for the specified shader resource view. Uses the largest mipmap level of the view to recursively generate the lower levels of the mipmap chain and stops with the smallest level that is specified by the view. </p>
<p>This will invalidate all previous descriptor and pipeline bindings, which will need to be reset by calls to <a class="el" href="structreshade_1_1api_1_1command__list.html#ace034fd1770ba272768d779c62300174" title="Binds an array of descriptor tables.">bind_descriptor_tables</a> or <a class="el" href="structreshade_1_1api_1_1command__list.html#a02d8805c699bf00279deb042dd7ffc7c" title="Directly binds a temporary descriptor table for the specfified shader pipeline stage and updates with...">push_descriptors</a> and <a class="el" href="structreshade_1_1api_1_1command__list.html#abbc22fd6a89454e4ac11497d8290e1b2" title="Binds a pipeline state object.">bind_pipeline</a>. The resource the shader resource view points to has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059aa24632445528325a6af3096b89d7e043">resource_usage::shader_resource</a> state and has to have been created with the <a class="el" href="namespacereshade_1_1api.html#ae92d24ded74e7f371f805b1d0d609043a479546bce1c2da73f9d7c4260a50cd03">resource_flags::generate_mipmaps</a> flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srv</td><td>Shader resource view to update.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5aa43b68ac312f25a8944e05166aa917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa43b68ac312f25a8944e05166aa917">&#9670;&nbsp;</a></span>insert_debug_marker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::insert_debug_marker </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>color</em>[4] = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a debug marker into the command list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Null-terminated string containing the label of the debug marker.</td></tr>
    <tr><td class="paramname">color</td><td>Optional RGBA color value associated with the debug marker.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e432c00882dbaa27b99177d33d5b398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e432c00882dbaa27b99177d33d5b398">&#9670;&nbsp;</a></span>push_constants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::push_constants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a>&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly updates constant values in the specified shader pipeline stages. </p>
<p>In D3D9 this updates the values of uniform registers, in D3D10/11 and OpenGL the constant buffer specified in the pipeline layout, in D3D12 it sets root constants and in Vulkan push constants.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a137624fb0450850037b499662edad3b0" title="Specifies whether partial push constant updates are supported. If this feature is not present,...">device_caps::partial_push_constant_updates</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stages</td><td>Shader stages that will use the updated constants.</td></tr>
    <tr><td class="paramname">layout</td><td>Pipeline layout that describes where the constants are located.</td></tr>
    <tr><td class="paramname">param</td><td>Layout parameter index of the constant range in the pipeline <em>layout</em>  (root parameter index in D3D12).</td></tr>
    <tr><td class="paramname">first</td><td>Start offset (in 32-bit values) to the first constant in the constant range to begin updating.</td></tr>
    <tr><td class="paramname">count</td><td>Number of 32-bit values to update.</td></tr>
    <tr><td class="paramname">values</td><td>Pointer to the first element of an array of 32-bit values to set the constants to. These can be floating-point, integer or boolean depending on what the shader is expecting.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02d8805c699bf00279deb042dd7ffc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d8805c699bf00279deb042dd7ffc7c">&#9670;&nbsp;</a></span>push_descriptors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::push_descriptors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#ae6d07e51daff3c4ff0b10c4ce20c77ee">shader_stage</a>&#160;</td>
          <td class="paramname"><em>stages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1pipeline__layout.html">pipeline_layout</a>&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1descriptor__table__update.html">descriptor_table_update</a> &amp;&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly binds a temporary descriptor table for the specfified shader pipeline stage and updates with an array of descriptors. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a1ad28dfe8e08a1a3e97dfa5d3b428d6a" title="Specifies whether partial push descriptor updates are supported. If this feature is not present,...">device_caps::partial_push_descriptor_updates</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stages</td><td>Shader stages that will use the updated descriptors.</td></tr>
    <tr><td class="paramname">layout</td><td>Pipeline layout that describes the descriptors.</td></tr>
    <tr><td class="paramname">param</td><td>Layout parameter index of the descriptor table in the pipeline <em>layout</em>  (root parameter index in D3D12, descriptor set index in Vulkan).</td></tr>
    <tr><td class="paramname">update</td><td>Range of descriptors to update in the temporary descriptor table (<a class="el" href="structreshade_1_1api_1_1descriptor__table__update.html#a1e35e6aa92d43f177c6a7a21abe88e94" title="Descriptor table to update.">descriptor_table_update::table</a> is ignored).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af394fff6c8eec9430b2413994c68af77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af394fff6c8eec9430b2413994c68af77">&#9670;&nbsp;</a></span>resolve_texture_region()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reshade::api::command_list::resolve_texture_region </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>source_subresource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structreshade_1_1api_1_1subresource__box.html">subresource_box</a> *&#160;</td>
          <td class="paramname"><em>source_box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreshade_1_1api_1_1resource.html">resource</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dest_subresource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dest_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dest_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dest_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereshade_1_1api.html#adbd317502610c902e7097163f5a9bb89">format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a region from the multisampled <em>source</em>  texture to the non-multisampled <em>dest</em> ination texture. </p>
<p>The <em>source</em>  resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a20ab132c61a964a35b03e0552c30aeb3">resource_usage::resolve_source</a> state. The <em>dest</em> ination resource has to be in the <a class="el" href="namespacereshade_1_1api.html#af7c77e737cfeb069db2fa6f72f35b059a17e1cf787fd346e6f1598b2b624f5b8f">resource_usage::resolve_dest</a> state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a6f1f028740db5e31adf9939e134f93b4" title="Specifies whether resolving a region of a resource rather than its entirety is supported....">device_caps::resolve_region</a>, <a class="el" href="namespacereshade_1_1api.html#ac1f75e72812269a7815296a0f248f9d0a65274c70133f904bf23b0794e1e17b6e" title="Specifies whether resolving depth-stencil resources is supported. If this feature is not present,...">device_caps::resolve_depth_stencil</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Texture resource to resolve from.</td></tr>
    <tr><td class="paramname">source_subresource</td><td>Index of the subresource of the <em>source</em>  texture to resolve from.</td></tr>
    <tr><td class="paramname">source_box</td><td>Optional 3D box (or <code>nullptr</code> to reference the entire subresource) that defines the region in the <em>source</em>  texture to resolve.</td></tr>
    <tr><td class="paramname">dest</td><td>Texture resource to resolve to.</td></tr>
    <tr><td class="paramname">dest_subresource</td><td>Index of the subresource of the <em>dest</em> ination texture to resolve to.</td></tr>
    <tr><td class="paramname">dest_x</td><td>Optional X offset (in texels) that defines the region in the <em>dest</em> ination texture to resolve to.</td></tr>
    <tr><td class="paramname">dest_y</td><td>Optional Y offset (in texels) that defines the region in the <em>dest</em> ination texture to resolve to.</td></tr>
    <tr><td class="paramname">dest_z</td><td>Optional Z offset (in texels) that defines the region in the <em>dest</em> ination texture to resolve to.</td></tr>
    <tr><td class="paramname">format</td><td>Format of the resource data.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="reshade__api__device_8hpp_source.html">reshade_api_device.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
